# JS继承

想要继承，就必须要提供个父类（继承谁，提供继承的属性）

![tupian](https://images2017.cnblogs.com/blog/1171086/201801/1171086-20180105141131753-1515292318.png)

### 1.原型链继承

![图片](https://images2017.cnblogs.com/blog/1171086/201801/1171086-20180105142159784-2086058141.png)

重点：让新实例的原型的关于父类的实例

特点：1、实例可继承的属性有：实例的构造函数的属性，父类原型的属性。

缺点：1、新实例无法向父类构造函数传参。

　　　2、继承单一。

　　　3、所有新实例都会共享父类实例的属性。

### 2.构造函数继承

![tupian](https://images2017.cnblogs.com/blog/1171086/201801/1171086-20180105145831456-1753461572.png)

重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））

特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。

　　　2、解决了原型链继承缺点1、2、3。

　　　3、可以继承多个构造函数属性（call多个）。

　　　4、在子实例中可向父实例传参。

缺点：1、只能继承父类构造函数的属性。

　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）

　　　3、每个新实例都有父类构造函数的副本，臃肿。

### 3.组合继承（组合原型链继承和借用构造函数继承）

![tupian](https://images2017.cnblogs.com/blog/1171086/201801/1171086-20180105155605534-390785677.png)

重点：**结合了两种模式的优点，传参和复用**

特点：1、可以继承父类原型上的属性，可以传参，可复用。

　　　2、每个新实例引入的构造函数属性是私有的。

缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。

### 4.寄生式继承

![tupian](https://images2017.cnblogs.com/blog/1171086/201801/1171086-20180106230703768-1647906557.png)

重点：就是给原型式继承外面套了个壳子。

优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。

缺点：没用到原型，无法复用。